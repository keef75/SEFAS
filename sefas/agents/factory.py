"""
Agent Factory for Dynamic Agent Creation

Creates all 15 SEFAS agents dynamically from configuration with full LLM parameter control.
"""

from typing import Dict, Any, Type, Optional
import yaml
from pathlib import Path

from sefas.agents.base import SelfEvolvingAgent
from sefas.agents.proposers import ProposerAgent, CreativeProposer, AnalyticalProposer, ResearchProposer
from sefas.agents.checkers import CheckerAgent, LogicChecker, SemanticChecker, ConsistencyChecker
from sefas.agents.orchestrator import OrchestratorAgent

class DynamicAgent(SelfEvolvingAgent):
    """Dynamic agent that can take any role based on configuration"""
    
    def __init__(self, agent_config: Dict[str, Any]):
        super().__init__(agent_config)
        self.agent_name = agent_config.get('name', self.role)
        self.strategy = agent_config.get('strategy', 'general')
        self.specialization = agent_config.get('specialization', 'adaptive')
        self.priority = agent_config.get('priority', 'medium')
        
    def _parse_response(self, response: str) -> Dict[str, Any]:
        """Parse LLM response into structured format"""
        
        # Try to extract JSON if present
        import json
        import re
        
        # Look for JSON blocks
        json_pattern = r'```(?:json)?\s*(\{.*?\})\s*```'
        json_match = re.search(json_pattern, response, re.DOTALL)
        
        if json_match:
            try:
                parsed_json = json.loads(json_match.group(1))
                if isinstance(parsed_json, dict):
                    # Add confidence if not present
                    if 'confidence' not in parsed_json:
                        parsed_json['confidence'] = self._extract_confidence(response)
                    return parsed_json
            except json.JSONDecodeError:
                pass
        
        # Fallback: structure the response based on role
        confidence = self._extract_confidence(response)
        
        if 'proposer' in self.role.lower():
            return {
                'proposal': response,
                'confidence': confidence,
                'reasoning': f"Generated by {self.agent_name}",
                'strategy': self.strategy,
                'agent_type': 'proposer'
            }
        elif 'checker' in self.role.lower() or 'validator' in self.role.lower():
            return {
                'verification': {
                    'overall_score': confidence,
                    'details': response,
                    'passed': confidence > 0.6
                },
                'confidence': confidence,
                'issues_found': self._extract_issues_from_text(response),
                'agent_type': 'checker'
            }
        elif 'orchestrator' in self.role.lower():
            return {
                'subclaims': self._extract_subclaims(response),
                'confidence': confidence,
                'decomposition_strategy': 'layered_parallel',
                'agent_type': 'orchestrator'
            }
        else:
            # Generic specialist agent
            return {
                'analysis': response,
                'confidence': confidence,
                'recommendations': self._extract_recommendations_from_text(response),
                'specialization': self.specialization,
                'agent_type': 'specialist'
            }
    
    def _extract_subclaims(self, text: str) -> list:
        """Extract subclaims from orchestrator response"""
        subclaims = []
        
        # Look for numbered items or bullet points
        import re
        
        # Pattern for numbered claims
        patterns = [
            r'(\d+)\.\s*([^\\n]+)',
            r'-\s*([^\\n]+)',
            r'\*\s*([^\\n]+)'
        ]
        
        for pattern in patterns:
            matches = re.findall(pattern, text)
            if matches:
                for i, match in enumerate(matches[:5]):  # Limit to 5 subclaims
                    if isinstance(match, tuple):
                        description = match[1] if len(match) > 1 else match[0]
                    else:
                        description = match
                    
                    subclaims.append({
                        'id': f'claim_{i+1}',
                        'description': description.strip(),
                        'type': 'analytical',
                        'assigned_agents': ['proposer_alpha', 'proposer_beta']
                    })
                break
        
        # If no patterns found, create a single claim
        if not subclaims:
            subclaims.append({
                'id': 'claim_1',
                'description': text[:200] + '...' if len(text) > 200 else text,
                'type': 'general',
                'assigned_agents': ['proposer_alpha']
            })
        
        return subclaims
    
    def _extract_issues_from_text(self, text: str) -> list:
        """Extract issues from checker response"""
        issues = []
        
        # Look for common issue indicators
        issue_patterns = [
            r'(?:issue|problem|error|concern|warning)[:\\s]+([^\\n\\.]+)',
            r'(?:fails?|incorrect|invalid|inconsistent)[:\\s]+([^\\n\\.]+)',
            r'(?:missing|lacking|absent)[:\\s]+([^\\n\\.]+)'
        ]
        
        import re
        for pattern in issue_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            issues.extend([match.strip() for match in matches])
        
        return issues[:5]  # Limit to 5 issues
    
    def _extract_recommendations_from_text(self, text: str) -> list:
        """Extract recommendations from specialist response"""
        recommendations = []
        
        # Look for recommendation indicators
        rec_patterns = [
            r'(?:recommend|suggest|advise|propose)[:\\s]+([^\\n\\.]+)',
            r'(?:should|must|need to|ought to)[:\\s]+([^\\n\\.]+)',
            r'(?:consider|try|implement)[:\\s]+([^\\n\\.]+)'
        ]
        
        import re
        for pattern in rec_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            recommendations.extend([match.strip() for match in matches])
        
        return recommendations[:3]  # Limit to 3 recommendations


class AgentFactory:
    """Factory for creating all 15 SEFAS agents from configuration"""
    
    def __init__(self, config_path: str = "config/agents.yaml"):
        self.config_path = Path(config_path)
        self.config = self._load_config()
        
        # Agent type mappings for specialized implementations
        self.agent_type_mapping = {
            'orchestrator': OrchestratorAgent,
            'creative_proposer': CreativeProposer,
            'analytical_proposer': AnalyticalProposer,
            'research_proposer': ResearchProposer,
            'logic_validator': LogicChecker,
            'semantic_validator': SemanticChecker,
            'consistency_validator': ConsistencyChecker,
            # All other agents use DynamicAgent
        }
    
    def _load_config(self) -> Dict[str, Any]:
        """Load agent configuration from YAML file"""
        try:
            with open(self.config_path, 'r') as f:
                return yaml.safe_load(f)
        except FileNotFoundError:
            raise FileNotFoundError(f"Agent configuration not found at {self.config_path}")
        except yaml.YAMLError as e:
            raise ValueError(f"Invalid YAML configuration: {e}")
    
    def create_agent(self, agent_id: str, agent_config: Dict[str, Any]) -> SelfEvolvingAgent:
        """Create a single agent from configuration"""
        
        # Add agent_id and name to config
        agent_config = agent_config.copy()
        agent_config['agent_id'] = agent_id
        if 'name' not in agent_config:
            agent_config['name'] = agent_id
        
        # Get the appropriate agent class
        role = agent_config.get('role', 'general')
        agent_class = self.agent_type_mapping.get(role, DynamicAgent)
        
        try:
            return agent_class(agent_config)
        except Exception as e:
            print(f"Warning: Failed to create {agent_id} with {agent_class.__name__}: {e}")
            # Fallback to DynamicAgent
            return DynamicAgent(agent_config)
    
    def create_all_agents(self) -> Dict[str, SelfEvolvingAgent]:
        """Create all agents from configuration"""
        
        agents = {}
        agent_configs = self.config.get('agents', {})
        
        print(f"🤖 Creating {len(agent_configs)} agents from configuration...")
        
        for agent_id, agent_config in agent_configs.items():
            try:
                agent = self.create_agent(agent_id, agent_config)
                agents[agent_id] = agent
                
                # Log agent creation details
                model = agent_config.get('model', 'unknown')
                temp = agent_config.get('temperature', 0.0)
                role = agent_config.get('role', 'unknown')
                name = agent_config.get('name', agent_id)
                
                print(f"  ✅ {agent_id}: {name} ({role}) - {model} @ temp={temp}")
                
            except Exception as e:
                print(f"  ❌ Failed to create {agent_id}: {e}")
                continue
        
        print(f"🎉 Successfully created {len(agents)}/{len(agent_configs)} agents")
        return agents
    
    def get_agent_config(self, agent_id: str) -> Optional[Dict[str, Any]]:
        """Get configuration for a specific agent"""
        return self.config.get('agents', {}).get(agent_id)
    
    def update_agent_config(self, agent_id: str, updates: Dict[str, Any]) -> bool:
        """Update configuration for a specific agent"""
        
        if 'agents' not in self.config:
            self.config['agents'] = {}
        
        if agent_id not in self.config['agents']:
            print(f"Warning: Agent {agent_id} not found in configuration")
            return False
        
        # Update the configuration
        self.config['agents'][agent_id].update(updates)
        
        # Save back to file
        try:
            with open(self.config_path, 'w') as f:
                yaml.dump(self.config, f, default_flow_style=False, sort_keys=False)
            print(f"✅ Updated configuration for {agent_id}")
            return True
        except Exception as e:
            print(f"❌ Failed to save configuration: {e}")
            return False
    
    def get_topology(self) -> Dict[str, Any]:
        """Get agent network topology"""
        return self.config.get('topology', {})
    
    def get_evolution_config(self) -> Dict[str, Any]:
        """Get evolution parameters"""
        return self.config.get('evolution', {})
    
    def get_execution_config(self) -> Dict[str, Any]:
        """Get execution strategy configuration"""
        return self.config.get('execution', {})
    
    def list_agents(self) -> Dict[str, Dict[str, Any]]:
        """List all available agents with their key properties"""
        
        agents_info = {}
        for agent_id, config in self.config.get('agents', {}).items():
            agents_info[agent_id] = {
                'name': config.get('name', agent_id),
                'role': config.get('role', 'unknown'),
                'model': config.get('model', 'default'),
                'temperature': config.get('temperature', 0.0),
                'max_tokens': config.get('max_tokens', 1500),
                'strategy': config.get('strategy', 'general'),
                'specialization': config.get('specialization', 'adaptive')
            }
        
        return agents_info
    
    def clone_agent(self, source_agent_id: str, new_agent_id: str, modifications: Dict[str, Any] = None) -> bool:
        """Clone an existing agent with optional modifications"""
        
        source_config = self.get_agent_config(source_agent_id)
        if not source_config:
            print(f"❌ Source agent {source_agent_id} not found")
            return False
        
        # Create new config based on source
        new_config = source_config.copy()
        new_config['name'] = f"Clone of {source_config.get('name', source_agent_id)}"
        
        # Apply modifications if provided
        if modifications:
            new_config.update(modifications)
        
        # Add to configuration
        if 'agents' not in self.config:
            self.config['agents'] = {}
        
        self.config['agents'][new_agent_id] = new_config
        
        # Save configuration
        try:
            with open(self.config_path, 'w') as f:
                yaml.dump(self.config, f, default_flow_style=False, sort_keys=False)
            print(f"✅ Cloned {source_agent_id} → {new_agent_id}")
            return True
        except Exception as e:
            print(f"❌ Failed to save cloned agent: {e}")
            return False


def create_agent_factory(config_path: str = "config/agents.yaml") -> AgentFactory:
    """Convenience function to create an agent factory"""
    return AgentFactory(config_path)


def quick_agent_test(agent_id: str = "orchestrator") -> bool:
    """Quick test to verify agent creation works"""
    
    try:
        factory = create_agent_factory()
        agent_config = factory.get_agent_config(agent_id)
        
        if not agent_config:
            print(f"❌ Agent {agent_id} not found in configuration")
            return False
        
        agent = factory.create_agent(agent_id, agent_config)
        print(f"✅ Successfully created {agent_id}: {agent.agent_name}")
        print(f"   Role: {agent.role}")
        print(f"   Model: {agent_config.get('model', 'default')}")
        print(f"   Temperature: {agent_config.get('temperature', 0.0)}")
        
        return True
        
    except Exception as e:
        print(f"❌ Agent test failed: {e}")
        return False


if __name__ == "__main__":
    # Test agent factory
    print("🧪 Testing Agent Factory...")
    
    factory = create_agent_factory()
    
    # List all agents
    print("\n📋 Available agents:")
    agents_info = factory.list_agents()
    for agent_id, info in agents_info.items():
        print(f"  {agent_id}: {info['name']} ({info['role']}) - {info['model']}")
    
    # Test creating all agents
    print(f"\n🚀 Creating all {len(agents_info)} agents...")
    agents = factory.create_all_agents()
    
    print(f"\n✅ Agent factory test complete: {len(agents)} agents ready!")